<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          汇编语言笔记 - 椎名的博客 | Charlot&#39;s Blog
        
    </title>

    <link rel="canonical" href="http://h2pl.github.io/2020/11/11/汇编语言笔记/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/hux-blog.min.css">


    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Charlot&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://h2pl.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('http://pic.mcatk.com/charlot-pictures/assembly-title.png')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#学习" title="学习">学习</a>
                        
                          <a class="tag" href="/tags/#操作系统" title="操作系统">操作系统</a>
                        
                    </div>
                    <h1>汇编语言笔记</h1>
                    <h2 class="subheading">王爽第三版笔记</h2>
                    <span class="meta">
                        Posted by Charlot on
                        2020-11-11
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h2><ol>
<li>汇编指令：机器码的助记符，有对应的机器码。</li>
<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行。</li>
<li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码<br>在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。</li>
</ol>
<h2 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h2><p>存储器，即我们平时所说的内存，存储了指令和数据。存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号，这些编号可以看作存储单元在存储器中的地址。<br>CPU想要进行数据的读写，必须和外部器件（芯片）进行下面3类信息交互：</p>
<ol>
<li>存储单元的地址（地址信息） </li>
<li>器件的选择，读或写的命令（控制信息）</li>
<li>读或写的数据（数据信息）</li>
</ol>
<p>CPU通过地址总线、控制总线和数据总线将这些信息传到存储器芯片中。<br>总线中有$n$根数据线就可以传输$2^n$的数据。控制总线是一些不同控制线的集合。控制总线的宽度决定了CPU对外部器件的控制能力。</p>
<h1 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h1><p>一个典型的CPU由运算器、控制器、寄存器等器件构成。在CPU中：</p>
<ol>
<li>运算器进行信息处理；</li>
<li>存储器进行信息存储；</li>
<li>控制器控制各种器件进行工作；</li>
<li>内部总线连接各种器件，在他们之间进行数据的传送。<br>8086CPU有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</li>
</ol>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>8086CPU的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。而上一代的寄存器都是8位的，因此这四个寄存器又可以分为两个可独立使用的8位寄存器来用。AX=AH+AL；BX=BH+BL；CX=CH+CL；DX=DH+DL。L代表的是X的低8位寄存器，H代表的是高八位寄存器。<br>8086CPU可以一次性处理以下两种尺寸的数据：</p>
<ol>
<li>字节：byte，8bit </li>
<li>字：word，2byte，16bit<h2 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="几条汇编指令"></a>几条汇编指令</h2></li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mov a,b</td>
<td style="text-align:center">把b移入a中</td>
</tr>
<tr>
<td style="text-align:center">add a,b</td>
<td style="text-align:center">a+=b</td>
</tr>
</tbody>
</table>
</div>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>8086CPU有20位地址总线，但它是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。所以8086CPU采用两个16位地址合成的方法来形成一个20位的物理地址。<br>当8086CPU要读写内存时：</p>
<ol>
<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；</li>
<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；</li>
<li>地址加法器将两个16位地址合成为一个20位的物理地址；</li>
<li>地址加法器通过内部总线将20位物理地址送入输入输出控制电路；</li>
<li>输入输出控制电路将20位物理地址送上地址总线</li>
<li>20位物理地址被地址总线传送到存储器<br>地址加法器采用<strong>物理地址=段地址*16+偏移地址</strong>的方法用段地址和偏移地址合成物理地址。</li>
</ol>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。</p>
<h2 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h2><p>CS为代码段寄存器，IP为指令指针寄存器。若CS内容为M，IP内容为N，则8086CPU将从内存为M*16+N单元开始读取一条指令并执行，其工作过程可以概括为：</p>
<ol>
<li>从CS：IP指向的内存单元中读取指令，读取的指令进入指令缓冲器；</li>
<li>IP=IP+所读取指令的长度，从而指向下一条指令；</li>
<li>执行指令。跳转到步骤(1)，重复这个过程。<br>mov指令无法修改CS：IP的值，jmp指令可以。<h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h2 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h2>CPU中用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。而在内存单元中低位字节放在低地址单元中，高位字节放在高地址单元中（小端法）。<br>字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</li>
</ol>
<h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><p>DS寄存器给出CPU要读写的内存单元的段地址。偏移地址用<code>[偏移地址]</code>表示<br>8086CPU不支持将数据直接送入段寄存器的操作，因此需要利用另一个一般的寄存器进行中转：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="number">0</span>],<span class="built_in">al</span></span><br></pre></td></tr></table></figure><br>用mov指令访问内存单元可以只给出单元的偏移地址，此时段地址默认在DS寄存器中</p>
<h2 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h2><p>一些可以执行的指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">目标</th>
<th style="text-align:center">来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mov</td>
<td style="text-align:center">寄存器</td>
<td style="text-align:center">数据</td>
</tr>
<tr>
<td style="text-align:center">mov</td>
<td style="text-align:center">寄存器</td>
<td style="text-align:center">寄存器</td>
</tr>
<tr>
<td style="text-align:center">mov</td>
<td style="text-align:center">寄存器</td>
<td style="text-align:center">内存单元</td>
</tr>
<tr>
<td style="text-align:center">mov</td>
<td style="text-align:center">内存单元</td>
<td style="text-align:center">寄存器</td>
</tr>
<tr>
<td style="text-align:center">mov</td>
<td style="text-align:center">段寄存器</td>
<td style="text-align:center">寄存器</td>
</tr>
<tr>
<td style="text-align:center">mov</td>
<td style="text-align:center">寄存器</td>
<td style="text-align:center">段寄存器</td>
</tr>
<tr>
<td style="text-align:center">mov</td>
<td style="text-align:center">内存单元</td>
<td style="text-align:center">段寄存器</td>
</tr>
<tr>
<td style="text-align:center">mov</td>
<td style="text-align:center">段寄存器</td>
<td style="text-align:center">内存单元</td>
</tr>
</tbody>
</table>
</div>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>特点：后进先出</p>
<h3 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h3><p>8086CPU提供入栈和出栈的指令分别是PUSH和POP<br>栈顶元素由SS:IP指向。<br><code>push ax</code>：</p>
<ol>
<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新栈顶</li>
<li>将ax的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li>
</ol>
<p><code>pop ax</code>：</p>
<ol>
<li>将SS:SP指向的内存单元处的数据送入ax中</li>
<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新栈顶</li>
</ol>
<p>内存分配：当你将地址A~地址B当作栈空间时，SP的初始位置应该是地址B的偏移地址+2.（栈空间的第一个元素的偏移地址是地址B的偏移地址-2，SP是基于偏移地址-2再加的4）<br>我们可以将一组地址连续、起始地址是16的倍数的内存单元当作栈空间来使用。使用的时候要注意栈可能越界（push和pop都可能越界），这个时候都会把其他不相干的地址空间的数据覆盖掉或者取出。</p>
<h1 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h1><h2 id="一个源程序从写出到执行的过程"><a href="#一个源程序从写出到执行的过程" class="headerlink" title="一个源程序从写出到执行的过程"></a>一个源程序从写出到执行的过程</h2><ol>
<li>编写汇编源程序</li>
<li>对源程序进行编译连接生成可执行文件</li>
<li>执行可执行文件中的程序</li>
</ol>
<p>可执行文件中包含两部分内容：</p>
<ol>
<li>程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）</li>
<li>相关的描述信息（比如，程序有多大、要占用多少内存空间等）<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2>下面是一段简单的汇编语言源程序<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>：codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0123H</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0456H</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00H</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21H</span></span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
汇编语言源程序中包含汇编指令和伪指令。<h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><h4 id="XXX-segment……-XXX-ends"><a href="#XXX-segment……-XXX-ends" class="headerlink" title="XXX segment…… XXX ends"></a>XXX segment…… XXX ends</h4>segment和ends的功能是定义一个段。segment说明一个段开始，ends说明一个段结束。一个段必须有一个名称来标识，使用格式为：<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 <span class="keyword">segment</span></span><br><span class="line">……</span><br><span class="line">段名 <span class="keyword">ends</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="end"><a href="#end" class="headerlink" title="end"></a>end</h4><p>end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。<br>end！=ends，后者是和segment成对使用的，可以看成是“end segment”。</p>
<h4 id="assume"><a href="#assume" class="headerlink" title="assume"></a>assume</h4><p>假设某一段寄存器和程序中的某一个用segment…end定义的段相关联。</p>
<h3 id="源程序中的“程序”"><a href="#源程序中的“程序”" class="headerlink" title="源程序中的“程序”"></a>源程序中的“程序”</h3><p>源程序包括伪指令和汇编指令。汇编指令组成了最终由计算机执行的程序，伪指令是由编译器处理的。这里说的程序就是指源程序中最终由计算机执行、处理的指令或数据</p>
<h3 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h3><p>一个标号作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址</p>
<h3 id="程序的结构"><a href="#程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h3><ol>
<li>定义一个段的名称</li>
<li>在这个段中写入汇编指令</li>
<li>指出程序在哪里结束（end）</li>
<li>将段和寄存器联系起来（assume）</li>
</ol>
<h3 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00H</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21H</span></span><br></pre></td></tr></table></figure>
<p>程序是由command.com从可执行文件中加载入内存并转交CPU的控制权的，因此结束运行后要把控制权还给它。<br>一个程序前会有256位的PSP内容，因此程序内容在DS所指的后256位处存储。</p>
<h2 id="编辑、编译、连接、执行"><a href="#编辑、编译、连接、执行" class="headerlink" title="编辑、编译、连接、执行"></a>编辑、编译、连接、执行</h2><p>见<a target="_blank" rel="noopener" href="https://blog.csdn.net/CharlotTataku/article/details/109548119">dosbox相关操作</a>。</p>
<h1 id="第五章-bx-和loop指令"><a href="#第五章-bx-和loop指令" class="headerlink" title="第五章 [bx]和loop指令"></a>第五章 [bx]和loop指令</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="bx-和内存单元的描述"><a href="#bx-和内存单元的描述" class="headerlink" title="[bx]和内存单元的描述"></a>[bx]和内存单元的描述</h3><p>[bx]表示一个内存单元，它的偏移地址在bx中（段地址在ds中）<br>（）表示一个寄存器或一个内存单元中的内容。里面的元素可以有3种类型：①寄存器名。②段寄存器名。③内存单元的物理地址（一个20位的数据）。<br>idata表示常量。</p>
<h2 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h2><p><code>mov ax,[bx]</code><br>bx中存放的数据作为一个偏移地址EA，段地址SA默认存放在ds中，将SA：EA处的数据送入ax中。即：(ax)=((ds)<em>16+(bx))。<br><code>mov [bx],ax</code><br>bx中存放的数据作为一个偏移地址EA，段地址SA默认存放在ds中，将ax处的数据送入SA：EA中。即：((ds)</em>16+(bx))=(ax)。</p>
<h2 id="Loop指令"><a href="#Loop指令" class="headerlink" title="Loop指令"></a>Loop指令</h2><p>loop指令的格式是：loop    标号。<br>CPU执行loop指令时，要进行两步操作：①(cx)=(cx)-1。②判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。<br>用cx和loop指令相配合实现循环功能的3个要点：</p>
<ol>
<li>在cx中存放循环次数。</li>
<li>loop指令中的标号所标识地址要在前面。</li>
<li>要循环执行的程序段，要写在标号和loop指令的中间。</li>
</ol>
<p>用cx和loop指令相配合实现循环功能的程序框架如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>, 循环次数</span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line">	循环执行的程序段</span><br><span class="line">	<span class="keyword">loop</span> s</span><br></pre></td></tr></table></figure><br>在汇编源程序中，数据不能以字母开头，以字母开头的数据要在前面补0。</p>
<h2 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h2><p><code>mov ax,ds:[bx]</code><br>这种出现在访问内存单元的指令中，用于显示地指明内存单元的段地址的“ds：”，在汇编语言中称为<strong>段前缀</strong>。</p>
<h2 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h2><p>我们需要直接向一段内存中写入内容，这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误。在DOS方式下，一般情况，0:200-0:2ff空间中没有系统或其他程序的数据或代码，以后我们需要直接向一段内存中写入内容时，就使用0:200-0:2ff这段空间</p>
<h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><h2 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h2><p><code>dw</code>定义字型数据，“define word”。dw定义的数据处于代码段的最开始，从CS中可以得到定义的数据的段地址，起始的偏移地址为0。<br>但因为前面的内容是数据而不是指令，如果直接运行会将这些数据错误地当成指令执行，因此需要表明程序的入口，从入口处开始执行指令。<br><code>start（可以替换成任何东西）</code>用于表明程序的入口<br><code>end start</code>用于通知编译器程序的入口在什么地方。<br>有了这两个伪指令我们可以这样安排程序的框架：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs : <span class="built_in">code</span></span><br><span class="line"><span class="built_in">code</span> segment</span><br><span class="line">			…数据…</span><br><span class="line">start:	</span><br><span class="line">			…代码…</span><br><span class="line"><span class="built_in">code</span> ends</span><br><span class="line"><span class="keyword">end</span> start</span><br></pre></td></tr></table></figure></p>
<h2 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h2><p><code>dw</code>不仅可以用来定义数据，还可以用来开辟空间以供之后使用。此时不管所开辟的空间里存储的是什么都没有关系，它们最终的效果是一样的。</p>
<h2 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h2><p><strong>定义多个段的方法</strong><br>对于不同的段有不同的段名即可。<br><strong>对段地址的引用</strong><br>段名相当于一个标号，它代表了段地址。因此在汇编指令里段名是一个代表地址的数值，不可以直接放到段寄存器里。<code>mov ds, data</code>这段代码是错的，应该写成<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br></pre></td></tr></table></figure><br><strong>“代码段”、“数据段”、“栈段”完全是我们的安排</strong><br>你可以更改任何命名，只需要最后实现的时候一一对应上就可以。</p>
<h1 id="第七章-更灵活的定位内存地址的方式"><a href="#第七章-更灵活的定位内存地址的方式" class="headerlink" title="第七章 更灵活的定位内存地址的方式"></a>第七章 更灵活的定位内存地址的方式</h1><h2 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h2><h3 id="and指令"><a href="#and指令" class="headerlink" title="and指令"></a>and指令</h3><p>“逻辑与”指令，按位进行与运算。</p>
<h3 id="or指令"><a href="#or指令" class="headerlink" title="or指令"></a>or指令</h3><p>“逻辑或”指令，按位进行或运算</p>
<h2 id="以字符形式给出的数据"><a href="#以字符形式给出的数据" class="headerlink" title="以字符形式给出的数据"></a>以字符形式给出的数据</h2><p>以<code>&#39; &#39;</code>的方式指明数据是以字符的形式给出的。编译器将把它们转化为相应的ASCII码</p>
<h2 id="大小写转换问题"><a href="#大小写转换问题" class="headerlink" title="大小写转换问题"></a>大小写转换问题</h2><p>通常的思路是大写字母<code>+20H</code>小写字母<code>-20H</code>。但这样会涉及很多判断。另一种方法是，大小写字母之间差32（10进制），因此他们的第五位（从第0位开始算起）是不一样的，大写字母第五位是0，小写字母第五位是1。通过<code>and 11011111B</code>可将小写字母变成大写字母。通过<code>or 00100000B</code>可将大写字母变为小写字母。</p>
<h1 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><h2 id="处理的数据在什么地方？"><a href="#处理的数据在什么地方？" class="headerlink" title="处理的数据在什么地方？"></a>处理的数据在什么地方？</h2><h3 id="bx、si、di、bp"><a href="#bx、si、di、bp" class="headerlink" title="bx、si、di、bp"></a>bx、si、di、bp</h3><ul>
<li>在8086CPU中，只有这4个寄存器可以用在<code>[ ]</code>中来进行内存单元的寻址</li>
<li>在<code>[ ]</code>中，这四个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di</li>
<li>只要在<code>[ ]</code>中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中。否则默认在ds中</li>
</ul>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>SA：段地址。EA：偏移地址</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[ idata ]</td>
<td style="text-align:center">EA=idata;SA=(ds)</td>
<td style="text-align:center">直接寻址</td>
</tr>
<tr>
<td style="text-align:center">[ bx ]</td>
<td style="text-align:center">EA=(bx);SA=(ds)</td>
<td style="text-align:center">寄存器间接寻址</td>
</tr>
<tr>
<td style="text-align:center">[ bx+idata ]</td>
<td style="text-align:center">EA=(bx)+idata;SA=(ds)</td>
<td style="text-align:center">寄存器相对寻址</td>
</tr>
<tr>
<td style="text-align:center">[ bx+si ]</td>
<td style="text-align:center">EA=(bx)+(si);SA=(ds)</td>
<td style="text-align:center">基址变址寻址</td>
</tr>
<tr>
<td style="text-align:center">[ bx+si+idata ]</td>
<td style="text-align:center">EA=(bx)+(si)+idata;SA=(ds)</td>
<td style="text-align:center">相对基址变址寻址</td>
</tr>
</tbody>
</table>
</div>
<p>汇编语言为结构体提供了更贴切的寻址书写方式。<code>[bx].idata</code>、<code>[bx].idata[si]</code>。</p>
<h2 id="指令要处理的数据有多长？"><a href="#指令要处理的数据有多长？" class="headerlink" title="指令要处理的数据有多长？"></a>指令要处理的数据有多长？</h2><ul>
<li>通过寄存器名指明要处理的数据的尺寸。</li>
<li>在没有寄存器名存在的情况下，用操作符<code>X ptr</code>来指明内存单元的长度，X在汇编指令中可以为word或byte。</li>
<li><code>push</code>指令只进行字操作。</li>
</ul>
<h2 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h2><p>div指令是除法指令。使用div做除法时应注意以下问题。</p>
<ul>
<li>除数：有8位和16位两种，在一个reg或内存单元中</li>
<li>被除数：<strong>默认放在AX或DX和AX中</strong>，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16为，被除数则为32位，在DX和AX中存放，DX中存放高16位，AX中存放低16位。</li>
<li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li>
</ul>
<h2 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h2><p><code>dd</code>是用来定义dword（double word，双字）型数据的，占4个字节。</p>
<h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p><code>dup</code>用来进行数据的重复，使用格式为<br><strong>d(字长) 重复的次数 dup （重复的数据）</strong><br>例如<code>db 3 dup(&#39;a&#39;,&#39;B&#39;)</code>的定义了6个字节，是’aBaBaB’。</p>
<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。统括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。<br>8086CPU的转移行为有以下几类：</p>
<ul>
<li>只修改IP时称为段内转移，比如<code>jmp ax</code>，短转移IP的修改范围为$-128—127$。近转移IP的修改范围为$-32768—32767$。</li>
<li>同时修改CS和IP时，称为段间转移，比如<code>jmp 1000:0</code></li>
</ul>
<p>8086CPU的转移指令分为以下几类：</p>
<ol>
<li>无条件转移指令（如：<code>jmp</code>）</li>
<li>条件转移指令</li>
<li>循环指令（如：<code>loop</code>）</li>
<li>过程</li>
<li>中断</li>
</ol>
<h2 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h2><p><code>offset</code>的功能是取得标号的偏移地址。比如下面的程序：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line">	start	:	<span class="keyword">mov</span> <span class="built_in">ax</span>,offset start		<span class="comment">;相当于mov ax,0</span></span><br><span class="line">		s	:	<span class="keyword">mov</span> <span class="built_in">ax</span>,offset s			<span class="comment">;相当于mov ax,3</span></span><br></pre></td></tr></table></figure><br>start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0。第一条指令长度为3个字节，所以第二条指令（s）的偏移地址是3。</p>
<h2 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h2><p><code>jmp</code>为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。<br><code>jmp</code>指令要给出两种信息：</p>
<ol>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移、段内近转移）</li>
</ol>
<h2 id="依据位移进行的jmp指令"><a href="#依据位移进行的jmp指令" class="headerlink" title="依据位移进行的jmp指令"></a>依据位移进行的jmp指令</h2><p>CPU在执行jmp指令的时候并不需要转移的目的地址。需要的是两条指令之间的<strong>位移</strong>，这个位移是由编译器通过标号算出(标号处的地址-jmp指令后的第一个字节的地址)，用补码表示的（有正负号）<br><code>jmp short 标号(转到标号处执行指令)</code>(IP)=(IP)+8位位移<br>这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为$-128—127$<br><code>jmp near 标号(转到标号处执行指令)</code>(IP)=(IP)+16位位移<br>这种格式的jmp指令实现的是段内近转移，它对IP的修改范围为$-32768—32767$</p>
<h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p><code>jmp far ptr 标号</code>实现的是段间转移，又称为远转移。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。这个时候机器码里会直接显示目的指令的地址(高地址处存放转移的段地址，低地址处存放指令的偏移地址)而不是两个指令之间的位移。</p>
<h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><p>指令格式：<code>jmp 16位reg</code><br>功能：(IP)=(16位reg)</p>
<h2 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h2><p>转移地址在内存中的jmp指令有两种格式</p>
<ol>
<li><code>jmp word ptr 内存单元地址（段内转移）</code>从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</li>
<li><code>jmp dword ptr 内存单元地址（段间转移）</code>从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。(CS)=(内存单元地址+2)(IP)=(内存单元地址)</li>
</ol>
<h2 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h2><p><code>jcxz</code>指令为有条件转移指令，所有的有条件转移指令都是<strong>短转移</strong>，在对应的机器码中包含转移的位移而不是目的地址。对IP的修改范围都是$-128—127$。<br>指令格式：<code>jcxs 标号</code>(如果(CX)=0，转移到标号处执行。)<br>操作：当(CX)=0时，(IP)=(IP)+8位位移。</p>
<h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop指令为循环指令，所有的循环指令都是<strong>短转移</strong>，在对应的机器码中包含转移的位移而不是目的地址。对IP的修改范围都是$-128—127$。<br>指令格式：<code>loop 标号</code>((CX)=(CX)-1，如果(CX)≠0,转移到标号处执行。)<br>操作：</p>
<ol>
<li>(CX)=(CX)-1</li>
<li>当(CX)≠0时，(IP)=(IP)+8位位移。</li>
</ol>
<h2 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h2><p>方便了程序段在内存中的浮动装配。</p>
<h2 id="编译器对转移位移超界的检测"><a href="#编译器对转移位移超界的检测" class="headerlink" title="编译器对转移位移超界的检测"></a>编译器对转移位移超界的检测</h2><p>根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。<br>形如<code>jmp 2000:0100</code>的转移指令，是在Debug中使用的汇编指令，汇编编译器并不认识。如果在源程序中使用，编译时也会报错。</p>
<h1 id="第十章-CALL和RET指令"><a href="#第十章-CALL和RET指令" class="headerlink" title="第十章 CALL和RET指令"></a>第十章 CALL和RET指令</h1><p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。</p>
<h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><p>CPU执行ret指令时，进行下面两步操作：</p>
<ol>
<li>(IP)=((ss)*16+(sp))</li>
<li>(sp)=(sp)+2</li>
</ol>
<p>可以看出CPU相当于在执行<code>pop IP</code>。</p>
<p>CPU执行retf指令时，进行下面4步操作：</p>
<ol>
<li>(IP)=((ss)*16+(sp))</li>
<li>(sp)=(sp)+2</li>
<li>(CS)=((ss)*16+(sp))</li>
<li>(sp)=(sp)+2</li>
</ol>
<p>可以看出CPU相当于在执行<code>pop IP</code> <code>pop CS</code>。</p>
<h2 id="call-指令"><a href="#call-指令" class="headerlink" title="call 指令"></a>call 指令</h2><p>CPU执行call指令时，进行两步操作：</p>
<ol>
<li>将当前的IP或CS和IP压入栈中</li>
<li>转移</li>
</ol>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p>
<h3 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h3><p><strong>call 标号</strong>（将当前的IP压栈后，转到标号处执行指令）<br>CPU执行此种格式的call指令时，进行如下的操作：</p>
<ol>
<li>(sp)=(sp)-2 ((ss)*16+(sp)=(IP)</li>
<li>(IP)=(IP)+16位位移</li>
</ol>
<p>16位位移=标号处的地址-call指令后的第一个字节的地址，范围为-32768~32767，用补码表示。16位位移由编译程序在编译时算出。<br>CPU在执行“call 标号”时，相当于进行：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>	<span class="built_in">IP</span></span><br><span class="line"><span class="keyword">jmp</span>		<span class="built_in">near</span> <span class="built_in">ptr</span> 标号</span><br></pre></td></tr></table></figure></p>
<h3 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h3><p><strong>call far ptr 标号</strong>实现的是段间转移。<br>CPU执行此种格式的call指令时，进行如下的操作。</p>
<ol>
<li>(sp)=(sp)-2 ((ss)<em>16+(sp))=(CS) (sp)=(sp)-2 ((ss)</em>16+(sp))=(IP)</li>
<li>(CS)=标号所在段的段地址 (IP)=标号在段中的偏移地址</li>
</ol>
<p>CPU在执行“call far ptr 标号”时相当于在执行：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>	<span class="built_in">CS</span></span><br><span class="line"><span class="keyword">push</span>	<span class="built_in">IP</span></span><br><span class="line"><span class="keyword">jmp</span>		<span class="built_in">far</span> <span class="built_in">ptr</span> 标号</span><br></pre></td></tr></table></figure></p>
<h3 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h3><p>指令格式：<strong>call 16位reg</strong><br>功能：<br>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<br>(IP)=(16位reg)<br>CPU在执行“call far ptr 标号”时相当于在执行：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>	<span class="built_in">IP</span></span><br><span class="line"><span class="keyword">jmp</span>		<span class="number">16</span>位reg</span><br></pre></td></tr></table></figure></p>
<h3 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h3><p>转移地址在内存中的call指令有两种格式<br>(1)<strong>call word ptr 内存单元地址</strong><br>CPU在执行“call word ptr 内存单元地址”时相当于在执行：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>	<span class="built_in">IP</span></span><br><span class="line"><span class="keyword">jmp</span>		<span class="built_in">word</span> <span class="built_in">ptr</span> 内存单元地址</span><br></pre></td></tr></table></figure><br>(2)<strong>call dword ptr 内存单元地址</strong><br>CPU在执行“call dword ptr 内存单元地址”时相当于在执行：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>	<span class="built_in">CS</span></span><br><span class="line"><span class="keyword">push</span>	<span class="built_in">IP</span></span><br><span class="line"><span class="keyword">jmp</span>		<span class="built_in">dword</span> <span class="built_in">ptr</span> 内存单元地址</span><br></pre></td></tr></table></figure></p>
<h2 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"><span class="symbol">	main:</span>	:</span><br><span class="line">			:</span><br><span class="line">			<span class="keyword">call</span> <span class="keyword">sub</span><span class="number">1</span>		<span class="comment">;调用子程序sub1</span></span><br><span class="line">			:</span><br><span class="line">			:</span><br><span class="line">			mov ax<span class="punctuation">,</span><span class="number">4</span><span class="keyword">c</span><span class="number">00</span>h</span><br><span class="line">			int <span class="number">21</span>h</span><br><span class="line">	<span class="keyword">sub</span><span class="number">1</span>:	:				<span class="comment">;子程序sub1开始</span></span><br><span class="line">			:</span><br><span class="line">			<span class="keyword">call</span> <span class="keyword">sub</span><span class="number">2</span>		<span class="comment">;调用子程序sub2</span></span><br><span class="line">			:</span><br><span class="line">			:</span><br><span class="line">			<span class="keyword">ret</span>				<span class="comment">;子程序返回</span></span><br><span class="line">	<span class="keyword">sub</span><span class="number">2</span>:	:				<span class="comment">;子程序sub2开始</span></span><br><span class="line">			:</span><br><span class="line">			:</span><br><span class="line">			<span class="keyword">ret</span>				<span class="comment">;子程序返回</span></span><br><span class="line">code ends</span><br><span class="line"><span class="keyword">end</span> main</span><br></pre></td></tr></table></figure>
<h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p><strong>mul    reg</strong><br><strong>mul    内存单元</strong><br>内存单元可以用不同的寻址方式给出，前面要声明是byte ptr还是word ptr。<br>使用mul做乘法的时候，注意以下两点：</p>
<ol>
<li>两个相乘的数：两个相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认在AX中，另一个放在16位reg或内存字单元中。</li>
<li>结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中放。</li>
</ol>
<h2 id="参数和结果传递的问题"><a href="#参数和结果传递的问题" class="headerlink" title="参数和结果传递的问题"></a>参数和结果传递的问题</h2><p>可以将其放入内存中，传递存储数据的地址。</p>
<h2 id="寄存器冲突的问题"><a href="#寄存器冲突的问题" class="headerlink" title="寄存器冲突的问题"></a>寄存器冲突的问题</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子程序开始:	子程序中使用的寄存器入栈</span><br><span class="line">			子程序内容</span><br><span class="line">			子程序中使用的寄存器出栈</span><br><span class="line">			返回(<span class="keyword">ret</span>,<span class="keyword">retf</span>)</span><br></pre></td></tr></table></figure>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2020/11/22/背包问题/" data-toggle="tooltip" data-placement="top" title="背包问题">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2020/11/07/动态规划最优二叉查找树问题/" data-toggle="tooltip" data-placement="top" title="动态规划最优二叉查找树问题">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#学习" title="学习">学习</a>
                        
                          <a class="tag" href="/tags/#操作系统" title="操作系统">操作系统</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://atksoto.com/" target="_blank">Soto-Blog</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>









    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/Charlot316">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Charlot&#39;s Blog 2022 
                    <br>
                    Theme by <a target="_blank" rel="noopener" href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a target="_blank" rel="noopener" href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://h2pl.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





<!-- Image to hack wechat -->
<img src="http://h2pl.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
